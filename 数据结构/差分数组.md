# 差分数组

假设有一个很大的数组(1000万以上)，因为业务需要会需要频繁的区间修改，比如[2000000,6000000]区间上全部加上1，如果暴力遍历的话，时间复杂度很高，每次修改操作都将会是$O(n)$，对于单点查询则是$O(1)$

而差分数组可以使得修改操作的时间复杂度降低到$O(1)$，对于查询则需要额外的初始化操作$O(n)$

考虑如下数组：


| i    | 0    | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| a[i] | 0    | 3    | 7    | 2    | 1    | 4    |

我们引入额外数组$d$来维护修改信息

$$
d[i]=
\begin{cases}
a[i]-a[i-1] \quad i>0\\
a[0]\qquad\qquad\quad i=0

\end{cases}
$$

| i    | 0    | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| a[i] | 0    | 3    | 7    | 2    | 1    | 4    |
| d[i] | 0    | 3    | 4    | -5   | -1   | 3    |

此时如果要进行区间修改，比如在[2,4]加3，只需要修改`d[2]+=3`，`d[4+1]-=3`

| i    | 0    | 1    | 2     | 3     | 4     | 5    |
| ---- | ---- | ---- | ----- | ----- | ----- | ---- |
| a[i] | 0    | 3    | 7(+3) | 2(+3) | 1(+3) | 4    |
| d[i] | 0    | 3    | 4+3   | -5    | -1    | 3-3  |
| d[i] | 0    | 3    | 7     | -5    | -1    | 0    |

需要查询数据的时候，我们由差分数组求出前缀和即可

| i                | 0    | 1    | 2    | 3    | 4    | 5    |
| ---------------- | ---- | ---- | ---- | ---- | ---- | ---- |
| d[i]             | 0    | 3    | 7    | -5   | -1   | 0    |
| a[i]=a[i-1]+d[i] | 0    | 3    | 10   | 5    | 4    | 4    |

## 例题

[leetcode 1893](https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/)

```java
class Solution {
    public boolean isCovered(int[][] ranges, int left, int right) {
        int[] diff = new int[52];

        // 差分数组
        for (int[] range : ranges) {
            diff[range[0]]++;
            diff[range[1] + 1]--;
        }

        // 计算前缀和
        for (int i = 1; i <= 50; i++) {
            diff[i] += diff[i - 1];
        }

        // 检查是否覆盖
        for (int i = left; i <= right; i++) {
            if (diff[i] < 1) {
                return false;
            }
        }

        return true;
    }
}

```

